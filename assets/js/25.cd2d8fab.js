(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{224:function(v,_,t){"use strict";t.r(_);var a=t(0),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),t("p",[v._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。"),t("br"),v._v("\n优点： 有序"),t("br"),v._v("\n缺点： 删除，插入数据效率低")]),v._v(" "),t("blockquote",[t("p",[v._v("线性表就是数据排成像一条线一样的结构.每个现行表上的数据最多只有前和后两个方向."),t("br"),v._v("\n常见的线性表结构：数组，链表、队列、栈等。")])]),v._v(" "),t("ol",[t("li",[v._v("搜索复杂度"),t("br"),v._v("\n最好情况时间复杂度为 O(1)，最坏情况时间复杂度为 O(n)， 平均时间复杂度为 O(n)"),t("br"),v._v("\n数组可以根据下标索引随机访问,直接找到索引为 k 的元素，此处复杂度为O(1)")]),v._v(" "),t("li",[v._v("删除复杂度"),t("br"),v._v("\n最好情况时间复杂度为 O(1)，最坏情况时间复杂度为 O(n)， 平均时间复杂度为 O(n)")]),v._v(" "),t("li",[v._v("插入复杂度"),t("br"),v._v("\n最好情况时间复杂度为 O(1)，最坏情况时间复杂度为 O(n)， 平均时间复杂度为 O(n)"),t("br"),v._v("\n数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素插入到第k个位置，此处复杂度为O(1)")])]),v._v(" "),t("h2",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),t("p",[v._v("数组一样，链表也是一种线性表")]),v._v(" "),t("p",[v._v("从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。")]),v._v(" "),t("p",[v._v("链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/algorithm/lb.png",alt:"链表"}})]),v._v(" "),t("ol",[t("li",[v._v("搜索复杂度为 O(n)： 需要从链头至链尾进行遍历")]),v._v(" "),t("li",[v._v("删除复杂度为 O(1)：只需更改指针指向即可")]),v._v(" "),t("li",[v._v("插入复杂度为 O(1)：只需更改指针指向即可")]),v._v(" "),t("li",[v._v("但是和数组比起来，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。")])]),v._v(" "),t("h2",{attrs:{id:"集合-（set）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集合-（set）"}},[v._v("#")]),v._v(" 集合 （SET）")]),v._v(" "),t("p",[v._v("集合是一组无序但彼此之间有一定关联的成员构成的,每一个成员在集合众只能出现一次")]),v._v(" "),t("ul",[t("li",[v._v("空集是不包含任何成员的集合")]),v._v(" "),t("li",[v._v("全集是包含一切可能成员的集合")]),v._v(" "),t("li",[v._v("子集是如果 集合A 的所有成员都属于 集合B，则 集合A 属于 集合B 的子集")]),v._v(" "),t("li",[v._v("如果两个集合的成员完全相同,则称两个集合完全相同")])]),v._v(" "),t("p",[v._v("集合操作")]),v._v(" "),t("ul",[t("li",[v._v("并集,将两个集合中的成员进行合并，得到一个新的集合")]),v._v(" "),t("li",[v._v("交集,两个集合中共同存在的成员组成一个新的集合")]),v._v(" "),t("li",[v._v("补集,属于一个集合而不属于另外一个集合成员的组成的集合")])]),v._v(" "),t("h2",{attrs:{id:"散列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[v._v("#")]),v._v(" 散列表")]),v._v(" "),t("p",[v._v("散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据结构叫做散列表。在散列表上插入、删除和取用数据都非常快。")]),v._v(" "),t("p",[v._v("散列表用的就是数组支持按照下标随机访问的时候,时间复杂度是0(1)的特性。")]),v._v(" "),t("p",[v._v("我们通过散列函数把每个元素的键值映射为为一个唯一的数组索引,然后将数据存储在数组中对应索引的位置。当我们按照键值查询元素时,我们用同样的散列函数,将键值转化数组标标,从对应的数组下标的位置取数据。")]),v._v(" "),t("p",[v._v("散列函数的设计要求:")]),v._v(" "),t("ul",[t("li",[v._v("散列函数计算得到的散列值是一个非负整数;.")]),v._v(" "),t("li",[v._v("如果key1 = key2,那hash(key1) == hash(key2);")]),v._v(" "),t("li",[v._v("如果key1 != key2,那hash(key1)  !=  hash(key2)")])]),v._v(" "),t("p",[v._v("散列函数的设计不能太复杂,散列函数生成值要尽可能随机并且均匀分布")]),v._v(" "),t("p",[v._v("即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞（collision），当碰撞发生时，我们需要利用一定的方法去解决碰撞。")]),v._v(" "),t("p",[v._v("解决散列冲突的方法有两种：")]),v._v(" "),t("ol",[t("li",[v._v("开放寻址法(open addressing)"),t("br"),v._v("\n当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空， 就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。")]),v._v(" "),t("li",[v._v("开链法:\n当碰撞发生时，仍然将键存储到通过散列算法产生的索引位置上，但实际上，每个数组元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了（即用二维数组实现）\n"),t("img",{attrs:{src:"/img/algorithm/chaining.png",alt:"开链法"}})])]),v._v(" "),t("h2",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),t("p",[v._v("栈是一种遵循 后进先出 原则的有序集合，新添加的或者待删除的元素都保存在栈的同一端，称为栈顶，另一端称为栈底"),t("br"),v._v("\n在栈里，新元素靠近栈顶，旧元素靠近栈底，用个图来看大概这样式的：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/algorithm/stack.jpeg",alt:"栈"}})]),v._v(" "),t("h2",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[v._v("#")]),v._v(" 队列")]),v._v(" "),t("p",[v._v("队列是遵循 先进先出 原则的一组有序的项，与栈的不同的是，栈不管是入栈还是出栈操作都是在栈顶操作，队列则是在队尾添加元素，队顶移除，用一个图来表示大概是这样事的：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/algorithm/dl.png",alt:"栈"}})])])}),[],!1,null,null,null);_.default=r.exports}}]);