## 数组

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。  
优点： 有序  
缺点： 删除，插入数据效率低

> 线性表就是数据排成像一条线一样的结构.每个现行表上的数据最多只有前和后两个方向.  
> 常见的线性表结构：数组，链表、队列、栈等。

1. 搜索复杂度  
    最好情况时间复杂度为 O(1)，最坏情况时间复杂度为 O(n)， 平均时间复杂度为 O(n)  
    数组可以根据下标索引随机访问,直接找到索引为 k 的元素，此处复杂度为O(1)
2. 删除复杂度  
    最好情况时间复杂度为 O(1)，最坏情况时间复杂度为 O(n)， 平均时间复杂度为 O(n)
3. 插入复杂度  
    最好情况时间复杂度为 O(1)，最坏情况时间复杂度为 O(n)， 平均时间复杂度为 O(n)  
    数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素插入到第k个位置，此处复杂度为O(1)

## 链表

数组一样，链表也是一种线性表  

从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。

链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。

![链表](/img/algorithm/lb.png)  

1. 搜索复杂度为 O(n)： 需要从链头至链尾进行遍历
2. 删除复杂度为 O(1)：只需更改指针指向即可
3. 插入复杂度为 O(1)：只需更改指针指向即可
4. 但是和数组比起来，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

## 集合 （SET）

集合是一组无序但彼此之间有一定关联的成员构成的,每一个成员在集合众只能出现一次

+ 空集是不包含任何成员的集合
+ 全集是包含一切可能成员的集合  
+ 子集是如果 集合A 的所有成员都属于 集合B，则 集合A 属于 集合B 的子集
+ 如果两个集合的成员完全相同,则称两个集合完全相同  

集合操作

+ 并集,将两个集合中的成员进行合并，得到一个新的集合
+ 交集,两个集合中共同存在的成员组成一个新的集合
+ 补集,属于一个集合而不属于另外一个集合成员的组成的集合

## 散列表

散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据结构叫做散列表。在散列表上插入、删除和取用数据都非常快。

散列表用的就是数组支持按照下标随机访问的时候,时间复杂度是0(1)的特性。

我们通过散列函数把每个元素的键值映射为为一个唯一的数组索引,然后将数据存储在数组中对应索引的位置。当我们按照键值查询元素时,我们用同样的散列函数,将键值转化数组标标,从对应的数组下标的位置取数据。

散列函数的设计要求:

+ 散列函数计算得到的散列值是一个非负整数;.
+ 如果key1 = key2,那hash(key1) == hash(key2);
+ 如果key1 != key2,那hash(key1)  !=  hash(key2)

散列函数的设计不能太复杂,散列函数生成值要尽可能随机并且均匀分布

即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞（collision），当碰撞发生时，我们需要利用一定的方法去解决碰撞。

解决散列冲突的方法有两种：

1. 开放寻址法(open addressing)  
    当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空， 就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。
2. 开链法:
    当碰撞发生时，仍然将键存储到通过散列算法产生的索引位置上，但实际上，每个数组元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了（即用二维数组实现）
    ![开链法](/img/algorithm/chaining.png)

## 栈

栈是一种遵循 后进先出 原则的有序集合，新添加的或者待删除的元素都保存在栈的同一端，称为栈顶，另一端称为栈底  
在栈里，新元素靠近栈顶，旧元素靠近栈底，用个图来看大概这样式的：

![栈](/img/algorithm/stack.jpeg)

## 队列

队列是遵循 先进先出 原则的一组有序的项，与栈的不同的是，栈不管是入栈还是出栈操作都是在栈顶操作，队列则是在队尾添加元素，队顶移除，用一个图来表示大概是这样事的：

![栈](/img/algorithm/dl.png)
