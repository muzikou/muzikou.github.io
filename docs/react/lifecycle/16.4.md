###  *<font>React v16.4</font>*  的生命周期
依然是先看图：

![life](/img/react/16.4.png)
#### 变更缘由
原来(  *<font>React v16.0</font>* 前)的生命周期在  *<font>React v16.0</font>*  推出的 *<font color="#d63200">Fiber</font>* 之后就不合适了，因为如果要开启 *<font color="#d63200">async rendering</font>*， 在 *<font color="#d63200">render</font>* 函数之前的所有函数，都有可能被执行多次。   
有上一篇我们知道下面的这些生命周期都是原来( *<font>React v16.0</font>* 前)在  *<font>render</font>*  前执行的:
+ *<font>componentWillMount</font>*
+ *<font>componentWillReceiveProps</font>*
+ *<font>shouldComponentUpdate</font>*
+ *<font>componentWillUpdate</font>*  
 
除了 *<font color="#d63200">shouldComponentUpdate</font>* ，其他在 *<font>render</font>* 函数之前的 所有函数( *<font>componentWillMount</font>*，*<font>componentWillReceiveProps</font>*，*<font>componentWillUpdate</font>*)都被 *<font color="#d63200">getDerivedStateFromProps</font>* 替代。  
也就是用一个静态函数  *<font>getDerivedStateFromProps</font>*  来取代被  *<font>deprecate</font>*  的几个生命周期函数，就是强制开发者在  *<font>render</font>* 之前只做无副作用的操作，而且能做的操作局限在根据  *<font>props</font>*  和  *<font>state</font>*  决定新的  *<font>state</font>* 。   
 *<font>React v16.0</font>* 刚推出的时候，是增加了一个 *<font>componentDidCatch</font>* 生命周期函数，这只是一个增量式修改，完全不影响原有生命周期函数;但是，到了  *<font>React v16.3</font>* ，大改动来了，引入了两个新的生命周期函数。  
#### 新引入了两个新的生命周期函数: getDerivedStateFromProps，getSnapshotBeforeUpdate
1. *<font color="#d63200">getDerivedStateFromProps</font>*    
 *<font>getDerivedStateFromProps</font>*  本来( *<font>React v16.3</font>* 中)是只在创建和更新(由父组件引发部分)，也就是不是不由父组件引发，那么  *<font>getDerivedStateFromProps</font>*  也不会被调用，如自身  *<font>setState</font>*  引发或者  *<font>forceUpdate</font>*  引发。

![life](/img/react/16.3.png) 

这样的话理解起来有点乱，在 *<font>React v16.4</font>* 中改正了这一点，让 *<font>getDerivedStateFromProps</font>* 无论是 *<font color="#d63200">Mounting</font>* 还是 *<font color="#d63200">Updating</font>*，也无论是因为什么引起的  *<font>Updating</font>* ，全部都会被调用，具体可看 *<font>React v16.4</font>*  的生命周期图。  
在  *<font>React v16.4</font>* 后， *<font>getDerivedStateFromProps(props, state)</font>* 在组件创建时和更新时的 *<font>render</font>* 方法之前调用，它应该返回一个对象来更新状态，或者返回 *<font>null</font>* 来不更新任何内容。    

2. *<font color="#d63200">getSnapshotBeforeUpdate </font>*  
 *<font>getSnapshotBeforeUpdate()</font>*  被调用于 *<font>render</font>* 之后，可以读取但无法使用 *<font>DOM</font>* 的时候。它使您的组件可以在可 能更改之前从 *<font>DOM</font>* 捕获一些信息(例如滚动位置)。此生命周期返回的任何值都将作为参数传递给  *<font>componentDidUpdate()</font>* 。
> 官网给的例子:
```js
class ScrollingList extends React.Component {
  constructor(props) {
    super(props);
    this.listRef = React.createRef();
  }
getSnapshotBeforeUpdate(prevProps, prevState) { //我们是否要添加新的 items 到列表?
// 捕捉滚动位置，以便我们可以稍后调整滚动.
if (prevProps.list.length < this.props.list.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
return null;
锦绣课堂React课程
}
componentDidUpdate(prevProps, prevState, snapshot) { //如果我们有snapshot值, 我们已经添加了 新的items.
// 调整滚动以至于这些新的items 不会将旧items推出视图。
// (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值) if (snapshot !== null) {
    const list = this.listRef.current;
    list.scrollTop = list.scrollHeight - snapshot;
  }
}
render() {
  return (
    <div ref={this.listRef}>{/* ...contents... */}</div>
  );
}
```

